--------------------------------------------------------------------------------
-- DATABASE SETUP SCRIPT (33 TABLES)
--------------------------------------------------------------------------------

DROP USER msp CASCADE;



CREATE USER msp IDENTIFIED BY msp
DEFAULT TABLESPACE users
TEMPORARY TABLESPACE temp
QUOTA UNLIMITED ON users;

GRANT CONNECT, RESOURCE TO msp;


CONNECT msp/msp; 

--------------------------------------------------------------------------------
-- 01. COMPANY
--------------------------------------------------------------------------------
CREATE TABLE company (
    company_id          VARCHAR2(50) PRIMARY KEY,
    company_name        VARCHAR2(200) NOT NULL UNIQUE,
    company_proprietor  VARCHAR2(200),
    phone_no            VARCHAR2(50) NOT NULL UNIQUE,
    email               VARCHAR2(200) NOT NULL UNIQUE,
    address             VARCHAR2(300),
    website             VARCHAR2(200) UNIQUE,
    contact_person      VARCHAR2(200),
    cp_designation      VARCHAR2(200),
    cp_phone_no         VARCHAR2(50),
    tag_line            VARCHAR2(300),
    mission_vision      VARCHAR2(1000),
    status              NUMBER,
    cre_by              VARCHAR2(100),
    cre_dt              DATE,
    upd_by              VARCHAR2(100),
    upd_dt              DATE
);

CREATE SEQUENCE company_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_company_bi
BEFORE INSERT OR UPDATE ON company FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.company_id IS NULL THEN
        v_seq := company_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.company_name),1,3));
        :NEW.company_id := NVL(v_code, 'COM') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 02. JOBS
--------------------------------------------------------------------------------
CREATE TABLE jobs (
    job_id       VARCHAR2(50) PRIMARY KEY,
    job_code     VARCHAR2(50),
    job_title    VARCHAR2(150),
    job_grade    VARCHAR2(1),
    min_salary   NUMBER,
    max_salary   NUMBER,
    status       NUMBER,
    cre_by       VARCHAR2(100),
    cre_dt       DATE,
    upd_by       VARCHAR2(100),
    upd_dt       DATE,
    CONSTRAINT chk_job_grade CHECK (job_grade IN ('A','B','C') OR job_grade IS NULL)
);

CREATE SEQUENCE jobs_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_jobs_bi
BEFORE INSERT OR UPDATE ON jobs FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.job_id IS NULL THEN
        v_seq := jobs_seq.NEXTVAL; 
        IF :NEW.job_code IS NOT NULL THEN
            v_code := UPPER(TRIM(:NEW.job_code));
            :NEW.job_id := v_code || TO_CHAR(v_seq);
        ELSE :NEW.job_id := TO_CHAR(v_seq); END IF;
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 03. CUSTOMERS
--------------------------------------------------------------------------------
CREATE TABLE customers (
    customer_id VARCHAR2(50) PRIMARY KEY,
    phone_no      VARCHAR2(50) UNIQUE, 
    customer_name VARCHAR2(150) NOT NULL,
    alt_phone_no  VARCHAR2(50),
    email         VARCHAR2(150),
    address       VARCHAR2(300),
    city          VARCHAR2(100),
    rewards       NUMBER DEFAULT 0,
    remarks       VARCHAR2(1000),
    status        NUMBER,
    cre_by        VARCHAR2(100),
    cre_dt        DATE,
    upd_by        VARCHAR2(100),
    upd_dt        DATE
);

CREATE SEQUENCE customers_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_customers_bi
BEFORE INSERT OR UPDATE ON customers
FOR EACH ROW
DECLARE
    v_seq  NUMBER;
    v_code VARCHAR2(10);
BEGIN
    IF INSERTING AND :NEW.customer_id IS NULL THEN
        IF :NEW.phone_no IS NOT NULL THEN
            :NEW.customer_id := :NEW.phone_no;
        ELSE
            v_seq  := customers_seq.NEXTVAL;
            v_code := UPPER(SUBSTR(TRIM(:NEW.customer_name),1,3));
            :NEW.customer_id := v_code || TO_CHAR(v_seq);
        END IF;
    END IF;

    IF INSERTING THEN
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/


--------------------------------------------------------------------------------
-- 04. PARTS_CATEGORY
--------------------------------------------------------------------------------
CREATE TABLE parts_category (
    parts_cat_id    VARCHAR2(50) PRIMARY KEY,
    parts_cat_code  VARCHAR2(50),
    parts_cat_name  VARCHAR2(150) UNIQUE,
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE
);

CREATE SEQUENCE parts_cat_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_parts_cat_bi
BEFORE INSERT OR UPDATE ON parts_category FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.parts_cat_id IS NULL THEN
        v_seq := parts_cat_seq.NEXTVAL;
        IF :NEW.parts_cat_code IS NOT NULL THEN
            v_code := UPPER(TRIM(:NEW.parts_cat_code));
            :NEW.parts_cat_id := v_code || TO_CHAR(v_seq);
        ELSE :NEW.parts_cat_id := TO_CHAR(v_seq); END IF;
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 05. PRODUCT_CATEGORIES
--------------------------------------------------------------------------------
CREATE TABLE product_categories (
    product_cat_id    VARCHAR2(50) PRIMARY KEY,
    product_cat_name  VARCHAR2(150) UNIQUE,
    status            NUMBER,
    cre_by            VARCHAR2(100),
    cre_dt            DATE,
    upd_by            VARCHAR2(100),
    upd_dt            DATE
);

CREATE SEQUENCE prod_cat_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_prod_cat_bi
BEFORE INSERT OR UPDATE ON product_categories FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.product_cat_id IS NULL THEN
        v_seq := prod_cat_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.product_cat_name),1,3));
        :NEW.product_cat_id := NVL(v_code, 'CAT') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 06. BRAND
--------------------------------------------------------------------------------
CREATE TABLE brand (
    brand_id      VARCHAR2(50) PRIMARY KEY,
    brand_name    VARCHAR2(150),
    model_name    VARCHAR2(150),
    brand_size    VARCHAR2(30),
    color         VARCHAR2(50),
    status        NUMBER,
    cre_by        VARCHAR2(100),
    cre_dt        DATE,
    upd_by        VARCHAR2(100),
    upd_dt        DATE
);

CREATE SEQUENCE brand_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_brand_bi
BEFORE INSERT OR UPDATE ON brand FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.brand_id IS NULL THEN
        v_seq := brand_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.brand_name),1,3));
        :NEW.brand_id := NVL(v_code, 'BRD') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 07. SUPPLIERS
--------------------------------------------------------------------------------
CREATE TABLE suppliers (
    supplier_id    VARCHAR2(50) PRIMARY KEY,
    supplier_name  VARCHAR2(150) NOT NULL,
    phone_no       VARCHAR2(30),
    email          VARCHAR2(150),
    address        VARCHAR2(300),
    contact_person VARCHAR2(100),
    cp_phone_no    VARCHAR2(30),
    cp_email       VARCHAR2(150),
    purchase_total NUMBER DEFAULT 0,
    pay_total      NUMBER DEFAULT 0,
    due            NUMBER GENERATED ALWAYS AS (NVL(purchase_total,0) - NVL(pay_total,0)) VIRTUAL,
    status         NUMBER,
    cre_by         VARCHAR2(100),
    cre_dt         DATE,
    upd_by         VARCHAR2(100),
    upd_dt         DATE
);

CREATE SEQUENCE suppliers_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_suppliers_bi
BEFORE INSERT OR UPDATE ON suppliers FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.supplier_id IS NULL THEN
        v_seq := suppliers_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.supplier_name),1,3));
        :NEW.supplier_id := NVL(v_code, 'SUP') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 08. SERVICE_LIST
--------------------------------------------------------------------------------
CREATE TABLE service_list (
    servicelist_id VARCHAR2(50) PRIMARY KEY,
    service_name   VARCHAR2(150) NOT NULL,
    service_desc   VARCHAR2(1000),
    service_cost   NUMBER DEFAULT 0,
    status         NUMBER,
    cre_by         VARCHAR2(100),
    cre_dt         DATE,
    upd_by         VARCHAR2(100),
    upd_dt         DATE
);

CREATE SEQUENCE service_list_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_service_list_bi
BEFORE INSERT OR UPDATE ON service_list FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.servicelist_id IS NULL THEN
        v_seq := service_list_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.service_name),1,3));
        :NEW.servicelist_id := NVL(v_code, 'SRV') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 09. EXPENSE_LIST
--------------------------------------------------------------------------------
CREATE TABLE expense_list (
    expense_type_id VARCHAR2(50) PRIMARY KEY,
    expense_code    VARCHAR2(50),
    type_name       VARCHAR2(200),
    description     VARCHAR2(1000),
    default_amount  NUMBER(15,2),
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE
);

CREATE SEQUENCE exp_list_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_exp_list_bi
BEFORE INSERT OR UPDATE ON expense_list FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.expense_type_id IS NULL THEN
        v_seq := exp_list_seq.NEXTVAL; 
        IF :NEW.expense_code IS NOT NULL THEN
            v_code := UPPER(TRIM(:NEW.expense_code));
            :NEW.expense_type_id := v_code || TO_CHAR(v_seq);
        ELSE :NEW.expense_type_id := TO_CHAR(v_seq); END IF;
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 10. SUB_CATEGORIES
--------------------------------------------------------------------------------
CREATE TABLE sub_categories (
    sub_cat_id       VARCHAR2(50) PRIMARY KEY,
    sub_cat_name     VARCHAR2(150),
    product_cat_id   VARCHAR2(50) NULL,
    status           NUMBER,
    cre_by           VARCHAR2(100),
    cre_dt           DATE,
    upd_by           VARCHAR2(100),
    upd_dt           DATE,
    CONSTRAINT fk_subcat_prodcat FOREIGN KEY (product_cat_id) REFERENCES product_categories(product_cat_id)
);

CREATE SEQUENCE sub_cat_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sub_cat_bi
BEFORE INSERT OR UPDATE ON sub_categories FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.sub_cat_id IS NULL THEN
        v_seq := sub_cat_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.sub_cat_name),1,3));
        :NEW.sub_cat_id := NVL(v_code, 'SUB') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 11. PRODUCTS
--------------------------------------------------------------------------------
CREATE TABLE products (
    product_id      VARCHAR2(50) PRIMARY KEY,
    product_code    VARCHAR2(30) UNIQUE,
    product_name    VARCHAR2(150) NOT NULL,
    supplier_id     VARCHAR2(50) NULL,
    category_id     VARCHAR2(50) NULL,
    sub_cat_id      VARCHAR2(50) NULL,
    brand_id        VARCHAR2(50) NULL,
    uom             VARCHAR2(20),
    mrp             NUMBER,
    purchase_price  NUMBER,
    warranty        NUMBER, 
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_p_sup FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_p_cat FOREIGN KEY (category_id) REFERENCES product_categories(product_cat_id),
    CONSTRAINT fk_p_sub FOREIGN KEY (sub_cat_id) REFERENCES sub_categories(sub_cat_id),
    CONSTRAINT fk_p_brd FOREIGN KEY (brand_id) REFERENCES brand(brand_id)
);

CREATE SEQUENCE products_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_products_bi
BEFORE INSERT OR UPDATE ON products
FOR EACH ROW
DECLARE
    v_seq  NUMBER;
    v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.product_id IS NULL THEN
        v_seq := products_seq.NEXTVAL;
        IF :NEW.product_code IS NOT NULL THEN
            v_code := UPPER(TRIM(:NEW.product_code));
            :NEW.product_id := v_code || TO_CHAR(v_seq);
        ELSE
            :NEW.product_id := TO_CHAR(v_seq);
        END IF;
    END IF;

    IF INSERTING THEN
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/


--------------------------------------------------------------------------------
-- 12. PARTS
--------------------------------------------------------------------------------
CREATE TABLE parts (
    parts_id       VARCHAR2(50) PRIMARY KEY,
    parts_code     VARCHAR2(50),
    parts_name     VARCHAR2(150),
    purchase_price NUMBER,
    mrp            NUMBER,
    parts_cat_id   VARCHAR2(50) NULL,
    status         NUMBER,
    cre_by         VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_parts_cat FOREIGN KEY (parts_cat_id) REFERENCES parts_category(parts_cat_id)
);

CREATE SEQUENCE parts_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_parts_bi
BEFORE INSERT OR UPDATE ON parts FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.parts_id IS NULL THEN
        v_seq := parts_seq.NEXTVAL;
        IF :NEW.parts_code IS NOT NULL THEN
            v_code := UPPER(TRIM(:NEW.parts_code));
            :NEW.parts_id := v_code || TO_CHAR(v_seq);
        ELSE :NEW.parts_id := TO_CHAR(v_seq); END IF;
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 13. DEPARTMENTS
--------------------------------------------------------------------------------
CREATE TABLE departments (
    department_id   VARCHAR2(50) PRIMARY KEY,
    department_name VARCHAR2(100),
    manager_id      VARCHAR2(50), 
    company_id      VARCHAR2(50) NULL,
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_dept_company FOREIGN KEY (company_id) REFERENCES company(company_id)
);

CREATE SEQUENCE departments_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

--------------------------------------------------------------------------------
-- 14. EMPLOYEES
--------------------------------------------------------------------------------
CREATE TABLE employees (
    employee_id   VARCHAR2(50) PRIMARY KEY,
    first_name    VARCHAR2(50),
    last_name     VARCHAR2(50) NOT NULL,
    email         VARCHAR2(150),
    phone_no      VARCHAR2(30),
    address       VARCHAR2(4000),
    hire_date     DATE,
    salary        NUMBER,
    job_id        VARCHAR2(50) NULL,
    manager_id    VARCHAR2(50), 
    department_id VARCHAR2(50) NULL,
    photo         BLOB,
    status        NUMBER,
    cre_by        VARCHAR2(100),
    cre_dt        DATE,
    upd_by        VARCHAR2(100),
    upd_dt        DATE,
    CONSTRAINT fk_emp_job  FOREIGN KEY (job_id) REFERENCES jobs(job_id),
    CONSTRAINT fk_emp_dept FOREIGN KEY (department_id) REFERENCES departments(department_id)
);

CREATE SEQUENCE employees_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

ALTER TABLE employees ADD CONSTRAINT fk_emp_mgr
FOREIGN KEY (manager_id)
REFERENCES employees(employee_id)
DEFERRABLE INITIALLY DEFERRED;

ALTER TABLE departments ADD CONSTRAINT fk_dept_mgr FOREIGN KEY (manager_id) REFERENCES employees(employee_id) DEFERRABLE INITIALLY DEFERRED;

CREATE OR REPLACE TRIGGER trg_departments_bi
BEFORE INSERT OR UPDATE ON departments FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.department_id IS NULL THEN
        v_seq := departments_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.department_name),1,3));
        :NEW.department_id := NVL(v_code, 'DEP') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_employees_bi
BEFORE INSERT OR UPDATE ON employees FOR EACH ROW
DECLARE v_seq NUMBER; v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.employee_id IS NULL THEN
        v_seq := employees_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.last_name),1,3));
        :NEW.employee_id := NVL(v_code, 'EMP') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 15. SALES_MASTER
--------------------------------------------------------------------------------
CREATE TABLE sales_master (
    invoice_id     VARCHAR2(50) PRIMARY KEY,
    invoice_date   DATE DEFAULT SYSDATE,
    discount       NUMBER DEFAULT 0,
    adjust_ref     VARCHAR2(50), 
    adjust_amount  NUMBER DEFAULT 0,
    grand_total    NUMBER DEFAULT 0,
    customer_id VARCHAR2(50) NULL,
    sales_by       VARCHAR2(50) NULL,
    status         NUMBER,
    cre_by         VARCHAR2(100),
    cre_dt         DATE,
    upd_by         VARCHAR2(100),
    upd_dt         DATE,
    CONSTRAINT fk_sales_cust FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    CONSTRAINT fk_sales_emp  FOREIGN KEY (sales_by) REFERENCES employees(employee_id)
);

CREATE SEQUENCE sales_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_master_bi
BEFORE INSERT OR UPDATE ON sales_master
FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.invoice_id IS NULL THEN
        :NEW.invoice_id := 'INV' || TO_CHAR(sales_seq.NEXTVAL);
    END IF;

    IF INSERTING THEN
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/


--------------------------------------------------------------------------------
-- 16. SALES_RETURN_MASTER
--------------------------------------------------------------------------------
CREATE TABLE sales_return_master (
    sales_return_id VARCHAR2(50) PRIMARY KEY,
    invoice_id      VARCHAR2(50) NULL, 
    customer_id  VARCHAR2(50) NULL,
    return_date     DATE DEFAULT SYSDATE,
    total_amount    NUMBER DEFAULT 0,
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_srm_inv   FOREIGN KEY (invoice_id) REFERENCES sales_master(invoice_id),
    CONSTRAINT fk_srm_cust  FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE SEQUENCE sales_ret_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_ret_bi
BEFORE INSERT OR UPDATE ON sales_return_master FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.sales_return_id IS NULL THEN
        :NEW.sales_return_id := 'SRT' || TO_CHAR(sales_ret_seq.NEXTVAL);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

ALTER TABLE sales_master ADD CONSTRAINT fk_sales_adjust FOREIGN KEY (adjust_ref) REFERENCES sales_return_master(sales_return_id);

--------------------------------------------------------------------------------
-- 17. SERVICE_MASTER
--------------------------------------------------------------------------------
CREATE TABLE service_master (
    service_id          VARCHAR2(50) PRIMARY KEY,
    service_date        DATE DEFAULT SYSDATE,
    customer_id      VARCHAR2(50) NULL,
    invoice_id          VARCHAR2(50) NULL, 
    warranty_applicable CHAR(1),
    servicelist_id      VARCHAR2(50) NULL,
    service_by          VARCHAR2(50) NULL,
    service_charge      NUMBER DEFAULT 0,
    parts_price         NUMBER DEFAULT 0,
    total_price         NUMBER GENERATED ALWAYS AS (NVL(service_charge,0) + NVL(parts_price,0)) VIRTUAL,
    status              NUMBER,
    cre_by              VARCHAR2(100),
    cre_dt              DATE,
    upd_by              VARCHAR2(100),
    upd_dt              DATE,
    CONSTRAINT fk_sm_cust FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    CONSTRAINT fk_sm_list FOREIGN KEY (servicelist_id) REFERENCES service_list(servicelist_id),
    CONSTRAINT fk_sm_emp  FOREIGN KEY (service_by) REFERENCES employees(employee_id),
    CONSTRAINT fk_sm_inv  FOREIGN KEY (invoice_id) REFERENCES sales_master(invoice_id)
);

CREATE SEQUENCE service_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

--------------------------------------------------------------------------------
-- 18. PRODUCT_ORDER_MASTER 
--------------------------------------------------------------------------------
CREATE TABLE product_order_master (
    order_id      VARCHAR2(50) PRIMARY KEY,
    order_date    DATE DEFAULT SYSDATE,
    supplier_id   VARCHAR2(50) NULL,
    expected_delivery_date DATE,
    order_by      VARCHAR2(50) NULL, 
    total_amount  NUMBER DEFAULT 0,
    Vat           NUMBER,
    Grand_total   NUMBER DEFAULT 0,
    status        NUMBER,
    cre_by        VARCHAR2(100),
    cre_dt        DATE,
    upd_by        VARCHAR2(100),
    upd_dt        DATE,
    CONSTRAINT fk_pom_sup  FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_pom_emp  FOREIGN KEY (order_by) REFERENCES employees(employee_id)
);

CREATE SEQUENCE order_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_prod_order_bi
BEFORE INSERT OR UPDATE ON product_order_master FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.order_id IS NULL THEN
        :NEW.order_id := 'ORD' || TO_CHAR(order_seq.NEXTVAL);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 19. PRODUCT_RECEIVE_MASTER 
--------------------------------------------------------------------------------
CREATE TABLE product_receive_master (
    receive_id      VARCHAR2(50) PRIMARY KEY,
    receive_date    DATE DEFAULT SYSDATE,
    order_id        VARCHAR2(50) NULL,
    sup_invoice_id  VARCHAR2(50) UNIQUE,
    supplier_id     VARCHAR2(50) NULL, 
    received_by     VARCHAR2(50) NULL, 
    total_amount    NUMBER DEFAULT 0,
    vat             NUMBER DEFAULT 0, 
    grand_total     NUMBER GENERATED ALWAYS AS (NVL(total_amount,0) + NVL(vat,0)) VIRTUAL,   
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_pr_emp FOREIGN KEY (received_by) REFERENCES employees(employee_id),
    CONSTRAINT fk_pr_sup FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_pr_order FOREIGN KEY (order_id) REFERENCES product_order_master(order_id)
);

CREATE SEQUENCE receive_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_prod_recv_bi
BEFORE INSERT OR UPDATE ON product_receive_master FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.receive_id IS NULL THEN
        :NEW.receive_id := 'RCV' || TO_CHAR(receive_seq.NEXTVAL);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 20. PRODUCT_RETURN_MASTER 
--------------------------------------------------------------------------------
CREATE TABLE product_return_master (
    return_id       VARCHAR2(50) PRIMARY KEY,
    supplier_id     VARCHAR2(50) NULL,
    receive_id      VARCHAR2(50) NULL, 
    return_date     DATE DEFAULT SYSDATE,
    return_by       VARCHAR2(50) NULL, 
    total_amount    NUMBER DEFAULT 0,
    adjusted_vat    NUMBER DEFAULT 0, 
    grand_total     NUMBER GENERATED ALWAYS AS (total_amount + (total_amount * adjusted_vat / 100)) VIRTUAL,  
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_pre_sup FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_pre_rcv FOREIGN KEY (receive_id) REFERENCES product_receive_master(receive_id),
    CONSTRAINT fk_pre_emp FOREIGN KEY (return_by) REFERENCES employees(employee_id)
);

CREATE SEQUENCE prod_ret_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_prod_ret_bi
BEFORE INSERT OR UPDATE ON product_return_master FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.return_id IS NULL THEN
        :NEW.return_id := 'PRT' || TO_CHAR(prod_ret_seq.NEXTVAL);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 21. DAMAGE
--------------------------------------------------------------------------------
CREATE TABLE damage (
    damage_id    VARCHAR2(50) PRIMARY KEY,
    damage_date  DATE DEFAULT SYSDATE,
    total_loss   NUMBER DEFAULT 0,
    status       NUMBER,
    cre_by       VARCHAR2(100),
    cre_dt       DATE,
    upd_by       VARCHAR2(100),
    upd_dt       DATE
);

CREATE SEQUENCE damage_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_damage_bi
BEFORE INSERT OR UPDATE ON damage FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.damage_id IS NULL THEN
        :NEW.damage_id := 'DMG' || TO_CHAR(damage_seq.NEXTVAL);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 22. STOCK
--------------------------------------------------------------------------------
CREATE TABLE stock (
    stock_id        VARCHAR2(50) PRIMARY KEY,
    product_id      VARCHAR2(50) NULL,
    supplier_id     VARCHAR2(50) NULL,
    product_cat_id  VARCHAR2(50) NULL,
    sub_cat_id      VARCHAR2(50) NULL,
    quantity        NUMBER DEFAULT 0,
    last_update     TIMESTAMP DEFAULT SYSTIMESTAMP,
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_s_p   FOREIGN KEY (product_id) REFERENCES products(product_id),
    CONSTRAINT fk_s_sup FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_prod_cat FOREIGN KEY (product_cat_id) REFERENCES product_categories(product_cat_id),
    CONSTRAINT chk_stock_qty CHECK (quantity >= 0)
);

CREATE SEQUENCE stock_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_stock_bi
BEFORE INSERT OR UPDATE ON stock FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.stock_id IS NULL THEN
        :NEW.stock_id := 'STK' || TO_CHAR(stock_seq.NEXTVAL);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF; 
    ELSIF UPDATING THEN
        :NEW.last_update := SYSTIMESTAMP; 
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 23. SERVICE_DETAILS
--------------------------------------------------------------------------------
CREATE TABLE service_details (
    service_det_id     VARCHAR2(50) PRIMARY KEY,
    service_id         VARCHAR2(50) NULL,
    product_id         VARCHAR2(50) NULL, 
    parts_id           VARCHAR2(50) NULL,
    quantity           NUMBER DEFAULT 1, 
    total_service_cost NUMBER, 
    description        VARCHAR2(1000), 
    warranty_status    VARCHAR2(50),
    CONSTRAINT fk_sd_master FOREIGN KEY (service_id) REFERENCES service_master(service_id),
    CONSTRAINT fk_sd_parts  FOREIGN KEY (parts_id) REFERENCES parts(parts_id),
    CONSTRAINT fk_sd_prod   FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE service_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_service_det_bi BEFORE INSERT ON service_details FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.service_det_id IS NULL THEN
	:NEW.service_det_id := 'SDT' || TO_CHAR(service_det_seq.NEXTVAL);  
END IF;
END;
/

--------------------------------------------------------------------------------
-- 24. SALES_DETAIL
--------------------------------------------------------------------------------
CREATE TABLE sales_detail (
    sales_det_id   VARCHAR2(50) PRIMARY KEY,
    invoice_id     VARCHAR2(50) NULL,
    product_id     VARCHAR2(50) NULL,
    mrp            NUMBER,
    purchase_price NUMBER,
    quantity       NUMBER,
    vat            NUMBER DEFAULT 0,
    description    VARCHAR2(1000), 
    CONSTRAINT fk_sdt_inv  FOREIGN KEY (invoice_id) REFERENCES sales_master(invoice_id) ON DELETE CASCADE,
    CONSTRAINT fk_sdt_prod FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE sales_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_det_bi BEFORE INSERT ON sales_detail FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.sales_det_id IS NULL THEN
	:NEW.sales_det_id := 'SLD' || TO_CHAR(sales_det_seq.NEXTVAL); 
END IF;
END;
/

--------------------------------------------------------------------------------
-- 25. SALES_RETURN_DETAILS
--------------------------------------------------------------------------------
CREATE TABLE sales_return_details (
    sales_return_det_id VARCHAR2(50) PRIMARY KEY,
    sales_return_id     VARCHAR2(50) NULL,
    product_id          VARCHAR2(50) NULL,
    mrp                 NUMBER,
    purchase_price      NUMBER,
    qty_return          NUMBER,
    reason              VARCHAR2(4000),
    CONSTRAINT fk_srd_mst FOREIGN KEY (sales_return_id) REFERENCES sales_return_master(sales_return_id),
    CONSTRAINT fk_srd_prd FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE sales_ret_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_ret_det_bi BEFORE INSERT ON sales_return_details FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.sales_return_det_id IS NULL THEN
	:NEW.sales_return_det_id := 'SRD' || TO_CHAR(sales_ret_det_seq.NEXTVAL); 
END IF;
END;
/

--------------------------------------------------------------------------------
-- 26. PRODUCT_ORDER_DETAIL
--------------------------------------------------------------------------------
CREATE TABLE product_order_detail (
    order_detail_id VARCHAR2(50) PRIMARY KEY,
    order_id        VARCHAR2(50) NULL,
    product_id      VARCHAR2(50) NULL,
    mrp             NUMBER, 
    purchase_price  NUMBER, 
    quantity        NUMBER,
    CONSTRAINT fk_pod_mst FOREIGN KEY (order_id) REFERENCES product_order_master(order_id),
    CONSTRAINT fk_pod_prd FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE order_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE OR REPLACE TRIGGER trg_order_det_bi BEFORE INSERT ON product_order_detail FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.order_detail_id IS NULL THEN
	:NEW.order_detail_id := 'ODT' || TO_CHAR(order_det_seq.NEXTVAL); 
END IF;
END;
/

--------------------------------------------------------------------------------
-- 27. PRODUCT_RECEIVE_DETAILS
--------------------------------------------------------------------------------
CREATE TABLE product_receive_details (
    receive_det_id   VARCHAR2(50) PRIMARY KEY,
    receive_id       VARCHAR2(50) NULL,
    product_id       VARCHAR2(50) NULL,
    mrp              NUMBER,             
    purchase_price   NUMBER,             
    receive_quantity NUMBER,
    CONSTRAINT fk_prd_mst FOREIGN KEY (receive_id) REFERENCES product_receive_master(receive_id),
    CONSTRAINT fk_prd_prd FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE recv_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE OR REPLACE TRIGGER trg_recv_det_bi BEFORE INSERT ON product_receive_details FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.receive_det_id IS NULL THEN
 :NEW.receive_det_id := 'RDT' || TO_CHAR(recv_det_seq.NEXTVAL); 
END IF;
END;
/

--------------------------------------------------------------------------------
-- 28. PRODUCT_RETURN_DETAILS
--------------------------------------------------------------------------------
CREATE TABLE product_return_details (
    return_detail_id VARCHAR2(50) PRIMARY KEY,
    return_id        VARCHAR2(50) NULL,
    product_id       VARCHAR2(50) NULL,
    mrp              NUMBER,             
    purchase_price   NUMBER,             
    return_quantity  NUMBER, 
    reason           VARCHAR2(1000),
    CONSTRAINT fk_prdet_mst FOREIGN KEY (return_id) REFERENCES product_return_master(return_id),
    CONSTRAINT fk_prdet_prd FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE prod_ret_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_prod_ret_det_bi BEFORE INSERT ON product_return_details FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.return_detail_id IS NULL THEN
:NEW.return_detail_id := 'PRD' || TO_CHAR(prod_ret_det_seq.NEXTVAL); 
END IF;
END;
/

--------------------------------------------------------------------------------
-- 29. EXPENSE_MASTER
--------------------------------------------------------------------------------
CREATE TABLE expense_master (
    expense_id      VARCHAR2(50) PRIMARY KEY,
    expense_code    VARCHAR2(50),
    expense_date    DATE,
    expense_by      VARCHAR2(100) NULL,
    expense_type_id VARCHAR2(50) NULL,
    remarks         VARCHAR2(1000),
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE,
    CONSTRAINT fk_ex_mst FOREIGN KEY (expense_type_id) REFERENCES expense_list(expense_type_id)
);

CREATE SEQUENCE exp_mst_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE OR REPLACE TRIGGER trg_exp_mst_bi BEFORE INSERT OR UPDATE ON expense_master FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.expense_id IS NULL THEN
        :NEW.expense_id := 'EXM' || TO_CHAR(exp_mst_seq.NEXTVAL); 
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 30. EXPENSE_DETAILS
--------------------------------------------------------------------------------
CREATE TABLE expense_details (
    expense_det_id    VARCHAR2(50) PRIMARY KEY,
    detail_code       VARCHAR2(50),
    expense_id        VARCHAR2(50) NOT NULL,
    expense_type_id   VARCHAR2(50) NOT NULL,
    description       VARCHAR2(1000),
    amount            NUMBER(15,2) DEFAULT 0,
    quantity          NUMBER DEFAULT 1,
    line_total        NUMBER(15,2),
    CONSTRAINT fk_ex_det_mst FOREIGN KEY (expense_id) REFERENCES expense_master(expense_id),
    CONSTRAINT fk_ex_det_typ FOREIGN KEY (expense_type_id) REFERENCES expense_list(expense_type_id)
);

CREATE SEQUENCE exp_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE OR REPLACE TRIGGER trg_exp_det_bi BEFORE INSERT OR UPDATE ON expense_details FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN 
    IF INSERTING AND :NEW.expense_det_id IS NULL THEN
        v_seq := exp_det_seq.NEXTVAL;
        IF :NEW.detail_code IS NOT NULL THEN :NEW.expense_det_id := :NEW.detail_code || TO_CHAR(v_seq);
        ELSE :NEW.expense_det_id := TO_CHAR(v_seq); END IF;
    END IF;
    :NEW.line_total := NVL(:NEW.amount,0) * NVL(:NEW.quantity,1); 
END;
/

--------------------------------------------------------------------------------
-- 31. DAMAGE_DETAIL 
--------------------------------------------------------------------------------
CREATE TABLE damage_detail (
    damage_detail_id VARCHAR2(50) PRIMARY KEY,
    damage_id        VARCHAR2(50),
    product_id       VARCHAR2(50),
    mrp              NUMBER,
    purchase_price   NUMBER,
    damage_quantity  NUMBER,
    reason           VARCHAR2(1000),
    CONSTRAINT fk_dmg_mst FOREIGN KEY (damage_id) REFERENCES damage(damage_id),
    CONSTRAINT fk_dmg_prd FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE SEQUENCE damage_det_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE OR REPLACE TRIGGER trg_damage_det_bi BEFORE INSERT ON damage_detail FOR EACH ROW 
BEGIN 
IF INSERTING AND :NEW.damage_detail_id IS NULL THEN
:NEW.damage_detail_id := 'DDT' || TO_CHAR(damage_det_seq.NEXTVAL);
END IF; 
END;
/

--------------------------------------------------------------------------------
-- 32. COM_USERS
--------------------------------------------------------------------------------
CREATE TABLE com_users (
    user_id     VARCHAR2(50) PRIMARY KEY,
    user_name   VARCHAR2(100) NOT NULL UNIQUE,
    password    VARCHAR2(200) NOT NULL,
    role        VARCHAR2(50) DEFAULT 'user' NOT NULL,
    employee_id VARCHAR2(50),
    status      NUMBER,
    cre_by      VARCHAR2(100),
    cre_dt      DATE,
    upd_by      VARCHAR2(100),
    upd_dt      DATE,
    CONSTRAINT fk_users_employee FOREIGN KEY (employee_id) REFERENCES employees(employee_id) ON DELETE SET NULL
);

CREATE SEQUENCE users_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_users_bi
BEFORE INSERT OR UPDATE ON com_users FOR EACH ROW
DECLARE 
    v_seq NUMBER; 
    v_code VARCHAR2(100);
BEGIN
    IF INSERTING AND :NEW.user_id IS NULL THEN
        v_seq := users_seq.NEXTVAL;
        v_code := UPPER(SUBSTR(TRIM(:NEW.user_name), 1, 3));
        :NEW.user_id := NVL(v_code, 'USR') || TO_CHAR(v_seq);
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
    END IF;
END;
/

--------------------------------------------------------------------------------
-- 33. PAYMENTS
--------------------------------------------------------------------------------
CREATE TABLE payments (
    payment_id   VARCHAR2(50) PRIMARY KEY,
    payment_date DATE NOT NULL,
    amount       NUMBER NOT NULL CHECK (amount > 0),
    payment_type VARCHAR2(50) NOT NULL,
    supplier_id  VARCHAR2(50) REFERENCES suppliers(supplier_id),
    status       NUMBER,
    cre_by       VARCHAR2(100),
    cre_dt       DATE,
    upd_by       VARCHAR2(100),
    upd_dt       DATE
);

CREATE SEQUENCE payments_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE OR REPLACE TRIGGER trg_payments_bi BEFORE INSERT OR UPDATE ON payments FOR EACH ROW
BEGIN
    IF INSERTING AND :NEW.payment_id IS NULL THEN :NEW.payment_id := 'PAY' || TO_CHAR(payments_seq.NEXTVAL); END IF;
END;
/

--------------------------------------------------------------------------------
-- 17(a).SERVICE MASTER TRIGGER HERE 
--------------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER trg_service_master_bi
BEFORE INSERT OR UPDATE ON service_master
FOR EACH ROW
DECLARE 
    v_inv_date DATE; 
    v_warranty NUMBER;
BEGIN
    -- ID generation (SAFE)
    IF INSERTING AND :NEW.service_id IS NULL THEN
        :NEW.service_id := 'SVM' || TO_CHAR(service_master_seq.NEXTVAL);
    END IF;

    -- Audit columns
    IF INSERTING THEN
        IF :NEW.status IS NULL THEN :NEW.status := 1; END IF;
        IF :NEW.cre_by IS NULL THEN :NEW.cre_by := USER; END IF;
        IF :NEW.cre_dt IS NULL THEN :NEW.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :NEW.upd_by IS NULL THEN :NEW.upd_by := USER; END IF;
        IF :NEW.upd_dt IS NULL THEN :NEW.upd_dt := SYSDATE; END IF;
    END IF;

    -- Warranty logic (SAFE)
    IF INSERTING AND :NEW.invoice_id IS NOT NULL THEN
        BEGIN
            SELECT m.invoice_date, p.warranty
            INTO v_inv_date, v_warranty
            FROM sales_master m
            JOIN sales_detail d ON m.invoice_id = d.invoice_id
            JOIN products p ON d.product_id = p.product_id
            WHERE m.invoice_id = :NEW.invoice_id
            AND ROWNUM = 1;

            IF v_inv_date + (v_warranty * 30) >= SYSDATE THEN
                :NEW.warranty_applicable := 'Y';
            ELSE
                :NEW.warranty_applicable := 'N';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                :NEW.warranty_applicable := 'N';
        END;
    END IF;
END;
/






